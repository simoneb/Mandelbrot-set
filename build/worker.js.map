{"version":3,"file":"worker.js","sources":["../../node_modules/@assemblyscript/loader/index.js","../../src/worker.ts"],"sourcesContent":["// Runtime header offsets\nconst ID_OFFSET = -8;\nconst SIZE_OFFSET = -4;\n\n// Runtime ids\nconst ARRAYBUFFER_ID = 0;\nconst STRING_ID = 1;\n// const ARRAYBUFFERVIEW_ID = 2;\n\n// Runtime type information\nconst ARRAYBUFFERVIEW = 1 << 0;\nconst ARRAY = 1 << 1;\nconst STATICARRAY = 1 << 2;\n// const SET = 1 << 3;\n// const MAP = 1 << 4;\nconst VAL_ALIGN_OFFSET = 6;\n// const VAL_ALIGN = 1 << VAL_ALIGN_OFFSET;\nconst VAL_SIGNED = 1 << 11;\nconst VAL_FLOAT = 1 << 12;\n// const VAL_NULLABLE = 1 << 13;\nconst VAL_MANAGED = 1 << 14;\n// const KEY_ALIGN_OFFSET = 15;\n// const KEY_ALIGN = 1 << KEY_ALIGN_OFFSET;\n// const KEY_SIGNED = 1 << 20;\n// const KEY_FLOAT = 1 << 21;\n// const KEY_NULLABLE = 1 << 22;\n// const KEY_MANAGED = 1 << 23;\n\n// Array(BufferView) layout\nconst ARRAYBUFFERVIEW_BUFFER_OFFSET = 0;\nconst ARRAYBUFFERVIEW_DATASTART_OFFSET = 4;\nconst ARRAYBUFFERVIEW_DATALENGTH_OFFSET = 8;\nconst ARRAYBUFFERVIEW_SIZE = 12;\nconst ARRAY_LENGTH_OFFSET = 12;\nconst ARRAY_SIZE = 16;\n\nconst BIGINT = typeof BigUint64Array !== \"undefined\";\nconst THIS = Symbol();\n\nconst STRING_DECODE_THRESHOLD = 32;\nconst decoder = new TextDecoder(\"utf-16le\");\n\n/** Gets a string from an U32 and an U16 view on a memory. */\nfunction getStringImpl(buffer, ptr) {\n  const len = new Uint32Array(buffer)[ptr + SIZE_OFFSET >>> 2] >>> 1;\n  const arr = new Uint16Array(buffer, ptr, len);\n  if (len <= STRING_DECODE_THRESHOLD) {\n    return String.fromCharCode.apply(String, arr);\n  }\n  return decoder.decode(arr);\n}\n\n/** Prepares the base module prior to instantiation. */\nfunction preInstantiate(imports) {\n  const extendedExports = {};\n\n  function getString(memory, ptr) {\n    if (!memory) return \"<yet unknown>\";\n    return getStringImpl(memory.buffer, ptr);\n  }\n\n  // add common imports used by stdlib for convenience\n  const env = (imports.env = imports.env || {});\n  env.abort = env.abort || function abort(msg, file, line, colm) {\n    const memory = extendedExports.memory || env.memory; // prefer exported, otherwise try imported\n    throw Error(`abort: ${getString(memory, msg)} at ${getString(memory, file)}:${line}:${colm}`);\n  };\n  env.trace = env.trace || function trace(msg, n, ...args) {\n    const memory = extendedExports.memory || env.memory;\n    console.log(`trace: ${getString(memory, msg)}${n ? \" \" : \"\"}${args.slice(0, n).join(\", \")}`);\n  };\n  env.seed = env.seed || Date.now;\n  imports.Math = imports.Math || Math;\n  imports.Date = imports.Date || Date;\n\n  return extendedExports;\n}\n\n/** Prepares the final module once instantiation is complete. */\nfunction postInstantiate(extendedExports, instance) {\n  const exports = instance.exports;\n  const memory = exports.memory;\n  const table = exports.table;\n  const new_ = exports[\"__new\"];\n  const retain = exports[\"__retain\"];\n  const rttiBase = exports[\"__rtti_base\"] || ~0; // oob if not present\n\n  /** Gets the runtime type info for the given id. */\n  function getInfo(id) {\n    const U32 = new Uint32Array(memory.buffer);\n    const count = U32[rttiBase >>> 2];\n    if ((id >>>= 0) >= count) throw Error(`invalid id: ${id}`);\n    return U32[(rttiBase + 4 >>> 2) + id * 2];\n  }\n\n  /** Gets and validate runtime type info for the given id for array like objects */\n  function getArrayInfo(id) {\n    const info = getInfo(id);\n    if (!(info & (ARRAYBUFFERVIEW | ARRAY | STATICARRAY))) throw Error(`not an array: ${id}, flags=${info}`);\n    return info;\n  }\n\n  /** Gets the runtime base id for the given id. */\n  function getBase(id) {\n    const U32 = new Uint32Array(memory.buffer);\n    const count = U32[rttiBase >>> 2];\n    if ((id >>>= 0) >= count) throw Error(`invalid id: ${id}`);\n    return U32[(rttiBase + 4 >>> 2) + id * 2 + 1];\n  }\n\n  /** Gets the runtime alignment of a collection's values. */\n  function getValueAlign(info) {\n    return 31 - Math.clz32((info >>> VAL_ALIGN_OFFSET) & 31); // -1 if none\n  }\n\n  /** Gets the runtime alignment of a collection's keys. */\n  // function getKeyAlign(info) {\n  //   return 31 - Math.clz32((info >>> KEY_ALIGN_OFFSET) & 31); // -1 if none\n  // }\n\n  /** Allocates a new string in the module's memory and returns its retained pointer. */\n  function __newString(str) {\n    const length = str.length;\n    const ptr = new_(length << 1, STRING_ID);\n    const U16 = new Uint16Array(memory.buffer);\n    for (var i = 0, p = ptr >>> 1; i < length; ++i) U16[p + i] = str.charCodeAt(i);\n    return ptr;\n  }\n\n  extendedExports.__newString = __newString;\n\n  /** Reads a string from the module's memory by its pointer. */\n  function __getString(ptr) {\n    const buffer = memory.buffer;\n    const id = new Uint32Array(buffer)[ptr + ID_OFFSET >>> 2];\n    if (id !== STRING_ID) throw Error(`not a string: ${ptr}`);\n    return getStringImpl(buffer, ptr);\n  }\n\n  extendedExports.__getString = __getString;\n\n  /** Gets the view matching the specified alignment, signedness and floatness. */\n  function getView(alignLog2, signed, float) {\n    const buffer = memory.buffer;\n    if (float) {\n      switch (alignLog2) {\n        case 2: return new Float32Array(buffer);\n        case 3: return new Float64Array(buffer);\n      }\n    } else {\n      switch (alignLog2) {\n        case 0: return new (signed ? Int8Array : Uint8Array)(buffer);\n        case 1: return new (signed ? Int16Array : Uint16Array)(buffer);\n        case 2: return new (signed ? Int32Array : Uint32Array)(buffer);\n        case 3: return new (signed ? BigInt64Array : BigUint64Array)(buffer);\n      }\n    }\n    throw Error(`unsupported align: ${alignLog2}`);\n  }\n\n  /** Allocates a new array in the module's memory and returns its retained pointer. */\n  function __newArray(id, values) {\n    const info = getArrayInfo(id);\n    const align = getValueAlign(info);\n    const length = values.length;\n    const buf = new_(length << align, info & STATICARRAY ? id : ARRAYBUFFER_ID);\n    let result;\n    if (info & STATICARRAY) {\n      result = buf;\n    } else {\n      const arr = new_(info & ARRAY ? ARRAY_SIZE : ARRAYBUFFERVIEW_SIZE, id);\n      const U32 = new Uint32Array(memory.buffer);\n      U32[arr + ARRAYBUFFERVIEW_BUFFER_OFFSET >>> 2] = retain(buf);\n      U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2] = buf;\n      U32[arr + ARRAYBUFFERVIEW_DATALENGTH_OFFSET >>> 2] = length << align;\n      if (info & ARRAY) U32[arr + ARRAY_LENGTH_OFFSET >>> 2] = length;\n      result = arr;\n    }\n    const view = getView(align, info & VAL_SIGNED, info & VAL_FLOAT);\n    if (info & VAL_MANAGED) {\n      for (let i = 0; i < length; ++i) view[(buf >>> align) + i] = retain(values[i]);\n    } else {\n      view.set(values, buf >>> align);\n    }\n    return result;\n  }\n\n  extendedExports.__newArray = __newArray;\n\n  /** Gets a live view on an array's values in the module's memory. Infers the array type from RTTI. */\n  function __getArrayView(arr) {\n    const U32 = new Uint32Array(memory.buffer);\n    const id = U32[arr + ID_OFFSET >>> 2];\n    const info = getArrayInfo(id);\n    const align = getValueAlign(info);\n    let buf = info & STATICARRAY\n      ? arr\n      : U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];\n    const length = info & ARRAY\n      ? U32[arr + ARRAY_LENGTH_OFFSET >>> 2]\n      : U32[buf + SIZE_OFFSET >>> 2] >>> align;\n    return getView(align, info & VAL_SIGNED, info & VAL_FLOAT).subarray(buf >>>= align, buf + length);\n  }\n\n  extendedExports.__getArrayView = __getArrayView;\n\n  /** Copies an array's values from the module's memory. Infers the array type from RTTI. */\n  function __getArray(arr) {\n    const input = __getArrayView(arr);\n    const len = input.length;\n    const out = new Array(len);\n    for (let i = 0; i < len; i++) out[i] = input[i];\n    return out;\n  }\n\n  extendedExports.__getArray = __getArray;\n\n  /** Copies an ArrayBuffer's value from the module's memory. */\n  function __getArrayBuffer(ptr) {\n    const buffer = memory.buffer;\n    const length = new Uint32Array(buffer)[ptr + SIZE_OFFSET >>> 2];\n    return buffer.slice(ptr, ptr + length);\n  }\n\n  extendedExports.__getArrayBuffer = __getArrayBuffer;\n\n  /** Copies a typed array's values from the module's memory. */\n  function getTypedArray(Type, alignLog2, ptr) {\n    return new Type(getTypedArrayView(Type, alignLog2, ptr));\n  }\n\n  /** Gets a live view on a typed array's values in the module's memory. */\n  function getTypedArrayView(Type, alignLog2, ptr) {\n    const buffer = memory.buffer;\n    const U32 = new Uint32Array(buffer);\n    const bufPtr = U32[ptr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];\n    return new Type(buffer, bufPtr, U32[bufPtr + SIZE_OFFSET >>> 2] >>> alignLog2);\n  }\n\n  /** Attach a set of get TypedArray and View functions to the exports. */\n  function attachTypedArrayFunctions(ctor, name, align) {\n    extendedExports[`__get${name}`] = getTypedArray.bind(null, ctor, align);\n    extendedExports[`__get${name}View`] = getTypedArrayView.bind(null, ctor, align);\n  }\n\n  [\n    Int8Array,\n    Uint8Array,\n    Uint8ClampedArray,\n    Int16Array,\n    Uint16Array,\n    Int32Array,\n    Uint32Array,\n    Float32Array,\n    Float64Array\n  ].forEach(ctor => {\n    attachTypedArrayFunctions(ctor, ctor.name, 31 - Math.clz32(ctor.BYTES_PER_ELEMENT));\n  });\n\n  if (BIGINT) {\n    [BigUint64Array, BigInt64Array].forEach(ctor => {\n      attachTypedArrayFunctions(ctor, ctor.name.slice(3), 3);\n    });\n  }\n\n  /** Tests whether an object is an instance of the class represented by the specified base id. */\n  function __instanceof(ptr, baseId) {\n    const U32 = new Uint32Array(memory.buffer);\n    let id = U32[ptr + ID_OFFSET >>> 2];\n    if (id <= U32[rttiBase >>> 2]) {\n      do {\n        if (id == baseId) return true;\n        id = getBase(id);\n      } while (id);\n    }\n    return false;\n  }\n\n  extendedExports.__instanceof = __instanceof;\n\n  // Pull basic exports to extendedExports so code in preInstantiate can use them\n  extendedExports.memory = extendedExports.memory || memory;\n  extendedExports.table  = extendedExports.table  || table;\n\n  // Demangle exports and provide the usual utility on the prototype\n  return demangle(exports, extendedExports);\n}\n\nfunction isResponse(src) {\n  return typeof Response !== \"undefined\" && src instanceof Response;\n}\n\nfunction isModule(src) {\n  return src instanceof WebAssembly.Module;\n}\n\n/** Asynchronously instantiates an AssemblyScript module from anything that can be instantiated. */\nexport async function instantiate(source, imports = {}) {\n  if (isResponse(source = await source)) return instantiateStreaming(source, imports);\n  const module = isModule(source) ? source : await WebAssembly.compile(source);\n  const extended = preInstantiate(imports);\n  const instance = await WebAssembly.instantiate(module, imports);\n  const exports = postInstantiate(extended, instance);\n  return { module, instance, exports };\n}\n\n/** Synchronously instantiates an AssemblyScript module from a WebAssembly.Module or binary buffer. */\nexport function instantiateSync(source, imports = {}) {\n  const module = isModule(source) ? source : new WebAssembly.Module(source);\n  const extended = preInstantiate(imports);\n  const instance = new WebAssembly.Instance(module, imports);\n  const exports = postInstantiate(extended, instance);\n  return { module, instance, exports };\n}\n\n/** Asynchronously instantiates an AssemblyScript module from a response, i.e. as obtained by `fetch`. */\nexport async function instantiateStreaming(source, imports = {}) {\n  if (!WebAssembly.instantiateStreaming) {\n    return instantiate(\n      isResponse(source = await source)\n        ? source.arrayBuffer()\n        : source,\n      imports\n    );\n  }\n  const extended = preInstantiate(imports);\n  const result = await WebAssembly.instantiateStreaming(source, imports);\n  const exports = postInstantiate(extended, result.instance);\n  return { ...result, exports };\n}\n\n/** Demangles an AssemblyScript module's exports to a friendly object structure. */\nexport function demangle(exports, extendedExports = {}) {\n  extendedExports = Object.create(extendedExports);\n  const setArgumentsLength = exports[\"__argumentsLength\"]\n    ? length => { exports[\"__argumentsLength\"].value = length; }\n    : exports[\"__setArgumentsLength\"] || exports[\"__setargc\"] || (() => { /* nop */ });\n  for (let internalName in exports) {\n    if (!Object.prototype.hasOwnProperty.call(exports, internalName)) continue;\n    const elem = exports[internalName];\n    let parts = internalName.split(\".\");\n    let curr = extendedExports;\n    while (parts.length > 1) {\n      let part = parts.shift();\n      if (!Object.prototype.hasOwnProperty.call(curr, part)) curr[part] = {};\n      curr = curr[part];\n    }\n    let name = parts[0];\n    let hash = name.indexOf(\"#\");\n    if (hash >= 0) {\n      const className = name.substring(0, hash);\n      const classElem = curr[className];\n      if (typeof classElem === \"undefined\" || !classElem.prototype) {\n        const ctor = function(...args) {\n          return ctor.wrap(ctor.prototype.constructor(0, ...args));\n        };\n        ctor.prototype = {\n          valueOf() { return this[THIS]; }\n        };\n        ctor.wrap = function(thisValue) {\n          return Object.create(ctor.prototype, { [THIS]: { value: thisValue, writable: false } });\n        };\n        if (classElem) Object.getOwnPropertyNames(classElem).forEach(name =>\n          Object.defineProperty(ctor, name, Object.getOwnPropertyDescriptor(classElem, name))\n        );\n        curr[className] = ctor;\n      }\n      name = name.substring(hash + 1);\n      curr = curr[className].prototype;\n      if (/^(get|set):/.test(name)) {\n        if (!Object.prototype.hasOwnProperty.call(curr, name = name.substring(4))) {\n          let getter = exports[internalName.replace(\"set:\", \"get:\")];\n          let setter = exports[internalName.replace(\"get:\", \"set:\")];\n          Object.defineProperty(curr, name, {\n            get() { return getter(this[THIS]); },\n            set(value) { setter(this[THIS], value); },\n            enumerable: true\n          });\n        }\n      } else {\n        if (name === 'constructor') {\n          (curr[name] = (...args) => {\n            setArgumentsLength(args.length);\n            return elem(...args);\n          }).original = elem;\n        } else { // instance method\n          (curr[name] = function(...args) { // !\n            setArgumentsLength(args.length);\n            return elem(this[THIS], ...args);\n          }).original = elem;\n        }\n      }\n    } else {\n      if (/^(get|set):/.test(name)) {\n        if (!Object.prototype.hasOwnProperty.call(curr, name = name.substring(4))) {\n          Object.defineProperty(curr, name, {\n            get: exports[internalName.replace(\"set:\", \"get:\")],\n            set: exports[internalName.replace(\"get:\", \"set:\")],\n            enumerable: true\n          });\n        }\n      } else if (typeof elem === \"function\" && elem !== setArgumentsLength) {\n        (curr[name] = (...args) => {\n          setArgumentsLength(args.length);\n          return elem(...args);\n        }).original = elem;\n      } else {\n        curr[name] = elem;\n      }\n    }\n  }\n  return extendedExports;\n}\n\nexport default {\n  instantiate,\n  instantiateSync,\n  instantiateStreaming,\n  demangle\n};\n","import loader from \"@assemblyscript/loader\";\n\ninterface command {\n    action: string,\n    data: any\n}\n\nlet moduleExports;\n\nconst myself: Worker = self as any;\n\nmyself.onmessage = async (event) => {\n\n    const { action, data } = event.data as command;\n\n    switch (action) {\n\n        case \"loadWasm\":\n            const module = await loader.instantiate(data, {\n                env: {},\n                index: {\n                    print: console.log\n                }\n            });\n            moduleExports = module.exports;\n            console.log(moduleExports);\n            myself.postMessage(null);\n        break;\n\n        case \"generate\":\n            const [width, height] = data as number[];\n            const pointer: number = moduleExports.generate(...data);\n            const imageDataArrayView: Uint8ClampedArray = moduleExports.__getUint8ClampedArrayView(pointer);\n            const imageDataArray = new Uint8ClampedArray(imageDataArrayView);\n            moduleExports.__release(pointer);\n            myself.postMessage(imageDataArray);\n        break;\n\n        default:\n            throw new Error(\"Unknown action: \" + action);\n            myself.postMessage(null);\n        break;\n    }\n}\n"],"names":["BIGINT","BigUint64Array","THIS","Symbol","decoder","TextDecoder","getStringImpl","buffer","ptr","len","Uint32Array","arr","Uint16Array","String","fromCharCode","apply","decode","preInstantiate","imports","extendedExports","getString","memory","env","abort","msg","file","line","colm","Error","trace","n","args","console","log","slice","join","seed","Date","now","Math","postInstantiate","instance","exports","table","new_","retain","rttiBase","getArrayInfo","id","info","U32","getInfo","getBase","getValueAlign","clz32","getView","alignLog2","signed","float","Float32Array","Float64Array","Int8Array","Uint8Array","Int16Array","Int32Array","BigInt64Array","__getArrayView","align","buf","length","subarray","getTypedArray","Type","getTypedArrayView","bufPtr","attachTypedArrayFunctions","ctor","name","bind","__newString","str","U16","i","p","charCodeAt","__getString","__newArray","values","result","view","set","__getArray","input","out","Array","__getArrayBuffer","Uint8ClampedArray","forEach","BYTES_PER_ELEMENT","__instanceof","baseId","demangle","isResponse","src","Response","isModule","WebAssembly","Module","async","instantiate","source","instantiateStreaming","module","compile","extended","arrayBuffer","Object","create","setArgumentsLength","value","internalName","prototype","hasOwnProperty","call","elem","parts","split","curr","part","shift","hash","indexOf","className","substring","classElem","wrap","constructor","[object Object]","this","thisValue","writable","getOwnPropertyNames","defineProperty","getOwnPropertyDescriptor","test","getter","replace","setter","enumerable","original","get","instantiateSync","Instance","moduleExports","myself","self","onmessage","event","action","data","loader","index","print","postMessage","pointer","generate","imageDataArrayView","__getUint8ClampedArrayView","imageDataArray","__release"],"mappings":"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"}